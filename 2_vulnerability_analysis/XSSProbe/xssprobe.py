import argparse
import logging
import sys
import time
import requests
from bs4 import BeautifulSoup
from typing import List, Optional
from urllib.parse import urlparse, parse_qs, urlencode

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(message)s',
    handlers=[
        logging.FileHandler('xssprobe.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

class XSSProbe:
    def __init__(self, url: str, payload_file: Optional[str] = None, quiet: bool = False):
        self.url = url
        self.payload_file = payload_file
        self.quiet = quiet
        self.payloads = self.load_payloads() if payload_file else [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "javascript:alert(1)"
        ]
        self.results = []
        self.output_file = f"xssprobe_results_{time.strftime('%Y%m%d_%H%M%S')}.txt"
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': 'XSSProbe/1.0'})

    def load_payloads(self) -> List[str]:
        """Load XSS payloads from file."""
        try:
            with open(self.payload_file, 'r') as f:
                return [line.strip() for line in f if line.strip()]
        except Exception as e:
            logging.error(f"Error reading payload file: {e}")
            return [
                "<script>alert(1)</script>",
                "<img src=x onerror=alert(1)>",
                "javascript:alert(1)"
            ]

    def get_form_inputs(self, html: str) -> List[dict]:
        """Extract form inputs from HTML."""
        try:
            soup = BeautifulSoup(html, 'html.parser')
            forms = soup.find_all('form')
            form_inputs = []
            for form in forms:
                inputs = form.find_all('input')
                data = {inp.get('name'): '' for inp in inputs if inp.get('name')}
                action = form.get('action', self.url)
                method = form.get('method', 'get').lower()
                form_inputs.append({'action': action, 'method': method, 'data': data})
            return form_inputs
        except Exception as e:
            logging.error(f"Error parsing HTML forms: {e}")
            return []

    def test_payload(self, url: str, payload: str, method: str = 'get', data: dict = None) -> Optional[str]:
        """Test a single payload and check response."""
        try:
            parsed_url = urlparse(url)
            query_params = parse_qs(parsed_url.query)
            
            # Test URL parameters
            for param in query_params:
                test_params = query_params.copy()
                test_params[param] = [payload]
                test_query = urlencode(test_params, doseq=True)
                test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{test_query}"
                
                response = self.session.get(test_url, timeout=5) if method == 'get' else \
                          self.session.post(test_url, data=data, timeout=5)
                
                if payload in response.text:
                    return f"Vulnerable: {test_url} with payload '{payload}'"
            
            # Test form inputs
            response = self.session.get(url, timeout=5)
            forms = self.get_form_inputs(response.text)
            for form in forms:
                test_data = form['data'].copy()
                for key in test_data:
                    test_data[key] = payload
                    action_url = form['action']
                    if form['method'] == 'get':
                        response = self.session.get(action_url, params=test_data, timeout=5)
                    else:
                        response = self.session.post(action_url, data=test_data, timeout=5)
                    if payload in response.text:
                        return f"Vulnerable: {action_url} (form) with payload '{payload}'"
            return None
        except Exception as e:
            logging.debug(f"Error testing payload '{payload}' on {url}: {e}")
            return None

    def run(self):
        """Run XSS scan."""
        logging.info(f"Starting XSSProbe on {self.url}")
        for payload in self.payloads:
            result = self.test_payload(self.url, payload)
            if result:
                self.results.append(result)
                logging.info(result)
                with open(self.output_file, 'a') as f:
                    f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] {result}\n")
            else:
                logging.info(f"No vulnerability found with payload '{payload}'")
        
        logging.info(f"Scan complete. Results saved to {self.output_file}")
        with open(self.output_file, 'a') as f:
            f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Scan complete\n")

def main():
    parser = argparse.ArgumentParser(description="XSSProbe - Test web apps for XSS vulnerabilities.")
    parser.add_argument('-u', '--url', required=True, help='Target URL (e.g., http://192.168.1.100)')
    parser.add_argument('-p', '--payload-file', help='File with XSS payloads (one per line)')
    parser.add_argument('-q', '--quiet', action='store_true', help='Quiet mode (log to file only)')

    args = parser.parse_args()

    if args.quiet:
        logging.getLogger().handlers = [logging.FileHandler('xssprobe.log')]

    probe = XSSProbe(url=args.url, payload_file=args.payload_file, quiet=args.quiet)
    try:
        probe.run()
    except KeyboardInterrupt:
        logging.info("Scan interrupted by user")
        sys.exit(0)

if __name__ == "__main__":
    main()