import argparse
import logging
import socket
import sys
import time
from typing import Optional

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(message)s',
    handlers=[
        logging.FileHandler('bufferbuster.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

class BufferBuster:
    def __init__(self, target: str, port: int, protocol: str, size: int, quiet: bool = False):
        self.target = target
        self.port = port
        self.protocol = protocol.lower()
        self.size = size
        self.quiet = quiet
        self.results = []
        self.output_file = f"bufferbuster_results_{time.strftime('%Y%m%d_%H%M%S')}.txt"
        self.supported_protocols = ['ftp', 'http', 'smtp']

    def generate_payload(self) -> bytes:
        """Generate a malformed payload."""
        try:
            if self.protocol == 'ftp':
                return b"USER " + b"A" * self.size + b"\r\n"
            elif self.protocol == 'http':
                return b"GET /" + b"A" * self.size + b" HTTP/1.1\r\nHost: " + self.target.encode() + b"\r\n\r\n"
            elif self.protocol == 'smtp':
                return b"HELO " + b"A" * self.size + b"\r\n"
            else:
                raise ValueError(f"Unsupported protocol: {self.protocol}")
        except Exception as e:
            logging.error(f"Error generating payload: {e}")
            return b""

    def test_buffer(self) -> Optional[str]:
        """Send payload and check server response."""
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(5)
                sock.connect((self.target, self.port))
                payload = self.generate_payload()
                if not payload:
                    return None
                
                sock.send(payload)
                try:
                    response = sock.recv(1024).decode(errors='ignore')
                    return f"Response received: {response[:100]}..."
                except socket.timeout:
                    return "No response (possible crash)"
                except ConnectionResetError:
                    return "Connection reset (possible crash)"
        except Exception as e:
            return f"Error: {str(e)}"

    def run(self):
        """Run buffer overflow test."""
        if self.protocol not in self.supported_protocols:
            logging.error(f"Protocol {self.protocol} not supported. Choose from {self.supported_protocols}")
            return
        
        logging.info(f"Starting BufferBuster on {self.target}:{self.port}, protocol: {self.protocol}, size: {self.size}")
        result = self.test_buffer()
        if result:
            self.results.append(result)
            logging.info(result)
            with open(self.output_file, 'a') as f:
                f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] {result}\n")
        else:
            logging.info("No response or error occurred")
        
        logging.info(f"Test complete. Results saved to {self.output_file}")
        with open(self.output_file, 'a') as f:
            f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Test complete\n")

def main():
    parser = argparse.ArgumentParser(description="BufferBuster - Test protocols for buffer overflows.")
    parser.add_argument('-t', '--target', required=True, help='Target IP (e.g., 192.168.1.100)')
    parser.add_argument('-p', '--port', type=int, required=True, help='Target port (e.g., 21)')
    parser.add_argument('-m', '--protocol', required=True, choices=['ftp', 'http', 'smtp'],
                        help='Protocol to test')
    parser.add_argument('-s', '--size', type=int, default=1000, help='Payload size (default: 1000)')
    parser.add_argument('-q', '--quiet', action='store_true', help='Quiet mode (log to file only)')

    args = parser.parse_args()

    if args.quiet:
        logging.getLogger().handlers = [logging.FileHandler('bufferbuster.log')]

    buster = BufferBuster(
        target=args.target,
        port=args.port,
        protocol=args.protocol,
        size=args.size,
        quiet=args.quiet
    )
    try:
        buster.run()
    except KeyboardInterrupt:
        logging.info("Test interrupted by user")
        sys.exit(0)

if __name__ == "__main__":
    main()