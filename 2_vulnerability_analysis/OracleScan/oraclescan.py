import argparse
import logging
import socket
import sys
import time
from typing import List, Optional

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(message)s',
    handlers=[
        logging.FileHandler('oraclescan.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

class OracleScan:
    def __init__(self, target: str, ports: List[int], sid_file: Optional[str] = None, quiet: bool = False):
        self.target = target
        self.ports = ports
        self.sid_file = sid_file
        self.quiet = quiet
        self.sids = self.load_sids() if sid_file else ['ORCL', 'XE', 'TEST']
        self.results = []
        self.output_file = f"oraclescan_results_{time.strftime('%Y%m%d_%H%M%S')}.txt"

    def load_sids(self) -> List[str]:
        """Load SIDs from file."""
        try:
            with open(self.sid_file, 'r') as f:
                return [line.strip() for line in f if line.strip()]
        except Exception as e:
            logging.error(f"Error reading SID file: {e}")
            return ['ORCL', 'XE', 'TEST']

    def send_tns_connect(self, host: str, port: int, sid: str) -> Optional[str]:
        """Send TNS connect packet and check response."""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((host, port))
            
            # Simplified TNS connect packet (minimal for enumeration)
            tns_packet = (
                b"\x00\x8a\x00\x00\x01\x00\x00\x00\x01\x36\x01\x2c\x00\x00\x08\x00"
                b"\x7f\xff\x7f\x08\x00\x00\x01\x00\x00\x20\x00\x3a\x00\x00\x00\x00"
                b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                f"(CONNECT_DATA=(SID={sid})(CID=(PROGRAM=)(HOST=)(USER=)))".encode()
            )
            packet_length = len(tns_packet).to_bytes(2, 'big')
            full_packet = packet_length + tns_packet[2:]
            
            sock.send(full_packet)
            response = sock.recv(1024)
            sock.close()
            
            # Check for valid TNS response (0x02 = Accept, 0x04 = Refuse)
            if response and response[4] in [0x02, 0x04]:
                return "Valid" if response[4] == 0x02 else "Refused"
            return None
        except Exception as e:
            logging.debug(f"TNS connect error on {host}:{port} for SID {sid}: {e}")
            return None

    def scan_port(self, port: int) -> bool:
        """Check if port is open."""
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(2)
                return sock.connect_ex((self.target, port)) == 0
        except Exception as e:
            logging.debug(f"Port scan error on {self.target}:{port}: {e}")
            return False

    def enumerate_sids(self, port: int):
        """Enumerate SIDs on an open port."""
        for sid in self.sids:
            result = self.send_tns_connect(self.target, port, sid)
            if result:
                msg = f"Port {port}: SID {sid} - {result}"
                self.results.append(msg)
                logging.info(msg)
                with open(self.output_file, 'a') as f:
                    f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] {msg}\n")

    def test_credentials(self, port: int, sid: str):
        """Test default credentials (simplified for education)."""
        credentials = [('sys', 'change_on_install'), ('system', 'manager')]
        for user, pwd in credentials:
            # Placeholder for credential testing (not implemented due to complexity)
            msg = f"Port {port}: SID {sid} - Credential test {user}:{pwd} (not implemented)"
            self.results.append(msg)
            logging.info(msg)
            with open(self.output_file, 'a') as f:
                f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] {msg}\n")

    def run(self):
        """Run the Oracle scan."""
        logging.info(f"Starting OracleScan on {self.target}, ports: {self.ports}")
        open_ports = []
        for port in self.ports:
            if self.scan_port(port):
                open_ports.append(port)
                logging.info(f"Port {port} is open")
            else:
                logging.info(f"Port {port} is closed")
        
        for port in open_ports:
            self.enumerate_sids(port)
            # Optionally test credentials for valid SIDs (simplified)
            for sid in self.sids:
                if any(sid in r for r in self.results if "Valid" in r):
                    self.test_credentials(port, sid)
        
        logging.info(f"Scan complete. Results saved to {self.output_file}")
        with open(self.output_file, 'a') as f:
            f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Scan complete\n")

def main():
    parser = argparse.ArgumentParser(description="OracleScan - Enumerate Oracle DBs for learning.")
    parser.add_argument('-t', '--target', required=True, help='Target IP (e.g., 192.168.1.100)')
    parser.add_argument('-p', '--ports', default='1521', help='Ports to scan (e.g., 1521,1522-1525)')
    parser.add_argument('-s', '--sid-file', help='File with SIDs (one per line)')
    parser.add_argument('-q', '--quiet', action='store_true', help='Quiet mode (log to file only)')

    args = parser.parse_args()

    # Parse ports
    ports = []
    for p in args.ports.split(','):
        if '-' in p:
            start, end = map(int, p.split('-'))
            ports.extend(range(start, end + 1))
        else:
            ports.append(int(p))

    if args.quiet:
        logging.getLogger().handlers = [logging.FileHandler('oraclescan.log')]

    scanner = OracleScan(target=args.target, ports=ports, sid_file=args.sid_file, quiet=args.quiet)
    try:
        scanner.run()
    except KeyboardInterrupt:
        logging.info("Scan interrupted by user")
        sys.exit(0)

if __name__ == "__main__":
    main()