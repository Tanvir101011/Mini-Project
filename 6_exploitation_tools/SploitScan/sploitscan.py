import argparse
import sqlite3
import csv
import os
import shutil
import sys
from datetime import datetime

def init_db(db_path):
    """Initialize SQLite database for exploit indexing."""
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS exploits
                 (id TEXT PRIMARY KEY, title TEXT, cve TEXT, platform TEXT, type TEXT, path TEXT, date_added TEXT)''')
    conn.commit()
    conn.close()

def index_exploits(repo_path, db_path):
    """Index exploits from CSV file into SQLite database."""
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    csv_path = os.path.join(repo_path, 'exploits.csv')
    
    if not os.path.exists(csv_path):
        print(f"[!] CSV file not found at {csv_path}")
        return
    
    with open(csv_path, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            c.execute("INSERT OR REPLACE INTO exploits (id, title, cve, platform, type, path, date_added) VALUES (?, ?, ?, ?, ?, ?, ?)",
                      (row['id'], row['title'], row['cve'], row['platform'], row['type'], row['path'], datetime.now().isoformat()))
    
    conn.commit()
    conn.close()
    print("[*] Exploit database indexed successfully.")

def search_exploits(db_path, terms=None, cve=None, platform=None, exploit_type=None, case_sensitive=False):
    """Search exploits in the database."""
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    query = "SELECT id, title, cve, platform, type, path FROM exploits WHERE 1=1"
    params = []
    
    if terms:
        for term in terms:
            if case_sensitive:
                query += " AND (title LIKE ? OR cve LIKE ?)"
                params.extend([f'%{term}%', f'%{term}%'])
            else:
                query += " AND (LOWER(title) LIKE LOWER(?) OR LOWER(cve) LIKE LOWER(?))"
                params.extend([f'%{term}%', f'%{term}%'])
    if cve:
        query += " AND cve = ?"
        params.append(cve)
    if platform:
        query += " AND platform LIKE ?"
        params.append(f'%{platform}%')
    if exploit_type:
        query += " AND type LIKE ?"
        params.append(f'%{exploit_type}%')
    
    c.execute(query, params)
    results = c.fetchall()
    conn.close()
    
    if not results:
        print("[!] No exploits found.")
        return []
    
    print("ID | Title | CVE | Platform | Type | Path")
    print("-" * 80)
    for row in results:
        print(f"{row[0]} | {row[1]} | {row[2]} | {row[3]} | {row[4]} | {row[5]}")
    return results

def mirror_exploit(db_path, exploit_id):
    """Copy an exploit file to the current working directory."""
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    c.execute("SELECT path FROM exploits WHERE id = ?", (exploit_id,))
    result = c.fetchone()
    conn.close()
    
    if not result:
        print(f"[!] Exploit ID {exploit_id} not found.")
        return
    
    src_path = result[0]
    if not os.path.exists(src_path):
        print(f"[!] Exploit file not found at {src_path}")
        return
    
    dst_path = os.path.join(os.getcwd(), os.path.basename(src_path))
    try:
        shutil.copy2(src_path, dst_path)
        print(f"[*] Exploit copied to {dst_path}")
    except Exception as e:
        print(f"[!] Error copying exploit: {e}")

def main():
    parser = argparse.ArgumentParser(description="SploitScan: Local Exploit Database Search Tool")
    parser.add_argument('terms', nargs='*', help="Search terms (e.g., wordpress remote)")
    parser.add_argument('-c', '--cve', help="Search by CVE identifier (e.g., CVE-2021-1234)")
    parser.add_argument('-p', '--platform', help="Filter by platform (e.g., windows, linux)")
    parser.add_argument('-t', '--type', help="Filter by exploit type (e.g., remote, local, webapps)")
    parser.add_argument('-m', '--mirror', help="Mirror exploit to current directory by ID")
    parser.add_argument('-i', '--index', action='store_true', help="Index exploits from CSV")
    parser.add_argument('-s', '--case-sensitive', action='store_true', help="Perform case-sensitive search")
    parser.add_argument('--repo', default='/opt/sploitscan', help="Path to exploit repository")
    args = parser.parse_args()

    db_path = os.path.join(args.repo, 'sploitscan.db')
    os.makedirs(args.repo, exist_ok=True)
    init_db(db_path)

    if args.index:
        index_exploits(args.repo, db_path)
        return

    if args.mirror:
        mirror_exploit(db_path, args.mirror)
        return

    if not args.terms and not args.cve and not args.platform and not args.type:
        parser.print_help()
        sys.exit(1)

    search_exploits(db_path, args.terms, args.cve, args.platform, args.type, args.case_sensitive)

if __name__ == "__main__":
    main()